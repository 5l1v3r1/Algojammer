{
  "title": "Timeline",
  "left": 1070,
  "top": 30,
  "width": 557,
  "height": 750,
  "sketches": [
    {
      "label": "Timeline",
      "left": "57px",
      "top": "27px",
      "width": 388,
      "height": 405,
      "style": "block",
      "colour": "rgb(39, 40, 34) none repeat scroll 0% 0% / auto padding-box border-box",
      "maxed": true,
      "code": "import bisect\n\ntimeline = { 'mouse':       0,    'steps':  50,\n             'dot_width':   8,    'grab':   False,\n             'line_height': 16.4, 'margin': 3.4 }\ncamera = { 'scale':     15.0, 's_scale':   1.0,\n           'x':        -20.0, 's_x':     -20.0 ,\n           'zoom_rate':  2.0}\njam['current_step'] = 0\n\n# Mouse controls\n@jam.on_click\ndef timeline_click(x, y, down):\n    if down:\n        timeline['grab'] = x\n    else:\n        timeline['grab'] = False\n\n@jam.on_wheel\ndef timeline_zoom(direction):\n    mouse_x = step_to_px(timeline['mouse'])\n    anchor = round((mouse_x + camera['s_x']) / camera['s_scale'])\n    \n    if direction == 1:\n        new_scale = clamp_scale(camera['scale'] * camera['zoom_rate'])\n    elif direction == -1:\n        new_scale = clamp_scale(camera['scale'] / camera['zoom_rate'])\n    \n    camera['x'] += anchor * (new_scale - camera['scale'])\n    camera['scale'] = new_scale\n\n\n# Utility functions\ndef line_to_px(line):\n    return timeline['line_height'] * line - timeline['margin']\n\ndef step_to_px(step):\n    return (step * camera['s_scale']) - camera['s_x']\n\ndef px_to_step(x):\n    return round((x + camera['s_x']) / camera['s_scale'])\n\ndef clamp_scale(scale):\n    return max(min(15, scale), (jam.canvas.width * 0.9) / timeline['steps'])\n\n# Drawing functions\ndef draw_ruler(canvas, step):\n    x, tag = step_to_px(step), '{:,}'.format(step)\n    canvas.line(x, 0, x, canvas.height)\n    canvas.text(x + 3, canvas.height - 3, tag, 14)\n\ndef draw_rulers(canvas):\n    step, s, scale = 10, 0, [2, 5]\n    while step < 80 / camera['scale']:\n        step *= scale[s]\n        s = 1 - s\n\n    shift = step * round(camera['x'] / (camera['scale'] * step))\n    \n    canvas.ink(80, 80, 80)\n    for i in range(10):\n        draw_ruler(canvas, shift + (i * step))\n\n    canvas.ink(115, 100, 100)\n    draw_ruler(canvas, jam['current_step'])\n    canvas.ink(150, 150, 120)\n    draw_ruler(canvas, timeline['mouse'])\n\ndef get_visible_runs(recording, canvas_width):\n    '''Efficiently calculate a representation of the Timeline'''\n    left_step  = max(0, px_to_step(0) - 1)\n    right_step = min(timeline['steps'], px_to_step(canvas_width) + 1)\n    gap = timeline['dot_width'] / camera['s_scale']\n    runs = []\n    for line in range(jam.num_lines() + 1):      # TODO\n        V = recording.visits(line)\n        if len(V) > 0:\n            s = e = bisect.bisect_left(V, left_step)\n            while e < len(V) and V[e] <= right_step:\n                jump = 1\n                while jump >= 1 and V[e] < right_step:\n                    if e + jump < len(V) and V[e + jump] - V[e] <= gap:\n                        e += jump   # This visit overlaps, extend run\n                        jump *= 2   # ..also, next time, try a bigger jump\n                    else:\n                        jump //= 2  # Didn't overlap - try smaller jump\n\n                num_visits = e - s + 1\n                runs += [(line, V[s], V[e], num_visits)]\n                s = e = e + 1\n    return runs\n\ndef draw_dots(canvas, recording):\n    runs = get_visible_runs(recording, canvas.width)\n    mouse_x = step_to_px(jam['current_step'])\n    mouse_line = recording.line(jam['current_step'])\n\n    for line, start, end, visits in runs:\n        a = step_to_px(start) - 4\n        b = step_to_px(end) + 4\n        if end < jam['current_step']:                     # Totally before\n            canvas.ink(220, 220, 200)\n            canvas.rect(a, line_to_px(line) - 4, b - a, 8)\n        elif start > jam['current_step']:                 # Totally after\n            canvas.ink(100, 100, 80)\n            canvas.rect(a, line_to_px(line) - 4, b - a, 8)\n        else:                                           # Split in two\n            canvas.ink(220, 220, 200)\n            canvas.rect(a, line_to_px(line) - 4, mouse_x - a, 8)\n            canvas.ink(100, 100, 80)\n            canvas.rect(mouse_x, line_to_px(line) - 4, b - mouse_x, 8)\n    \n    canvas.ink(220, 220, 200)\n    canvas.rect(mouse_x - 5, line_to_px(mouse_line) - 5, 10, 10)  # Current step\n\ndef draw_timeline(canvas, recording):\n    camera['x'] = max(camera['x'], -15.0)\n    camera['scale'] = clamp_scale(camera['scale'])\n\n    if timeline['grab']:\n        mouse_x, _ = jam.mouse()\n        camera['x'] += (timeline['grab'] - mouse_x)\n        timeline['grab'] = mouse_x\n\n    camera['s_x'] += (camera['x'] - camera['s_x']) * 0.4\n    camera['s_scale'] += (camera['scale'] - camera['s_scale']) * 0.4\n    \n    mx, _ = jam.mouse()\n    mouse_step = round((mx + camera['x']) / camera['scale'])\n    timeline['mouse'] = max(0, min(mouse_step, timeline['steps'] - 1))\n    \n    # Set global variable so other sketches can read it\n    if jam.key('Shift') and 0 <= mx <= canvas.width:\n        jam['current_step'] = timeline['mouse']\n\n    canvas.clear()\n    draw_rulers(canvas)\n    if recording:\n        canvas.ink(115, 100, 100)\n        line = recording.line(jam['current_step'])\n        canvas.line(0, line_to_px(line), canvas.width, line_to_px(line))\n        \n        timeline['steps'] = max(1, recording.steps())\n        draw_dots(canvas, recording)\n\n@jam.on_refresh\ndef refresh():\n    draw_timeline(jam.canvas, jam.control.recording)\n\n\n",
      "animate": true
    }
  ]
}